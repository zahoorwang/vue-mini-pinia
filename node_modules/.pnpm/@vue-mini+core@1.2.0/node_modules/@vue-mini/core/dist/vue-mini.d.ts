/// <reference types="miniprogram-api-typings" />
import { DebuggerOptions, WatchEffect, WatchHandle, WatchSource, WatchCallback, ReactiveMarker } from '@vue/reactivity';
export { ComputedGetter, ComputedRef, ComputedSetter, CustomRefFactory, DebuggerEvent, DebuggerEventExtraInfo, DebuggerOptions, DeepReadonly, EffectScheduler, EffectScope, MaybeRef, MaybeRefOrGetter, Raw, Reactive, ReactiveEffect, ReactiveEffectOptions, ReactiveEffectRunner, ReactiveFlags, Ref, ShallowReactive, ShallowRef, ShallowUnwrapRef, ToRef, ToRefs, TrackOpTypes, TriggerOpTypes, UnwrapNestedRefs, UnwrapRef, WatchCallback, WatchEffect, WatchHandle, WatchSource, WatchStopHandle, WritableComputedOptions, WritableComputedRef, computed, customRef, effect, effectScope, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, onWatcherCleanup, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, toValue, triggerRef, unref } from '@vue/reactivity';

type MaybeUndefined<T, I> = I extends true ? T | undefined : T;
type MapSources<T, Immediate> = {
    [K in keyof T]: T[K] extends WatchSource<infer V> ? MaybeUndefined<V, Immediate> : T[K] extends object ? MaybeUndefined<T[K], Immediate> : never;
};
interface WatchEffectOptions extends DebuggerOptions {
    flush?: 'pre' | 'post' | 'sync';
}
interface WatchOptions<Immediate = boolean> extends WatchEffectOptions {
    immediate?: Immediate;
    deep?: boolean | number;
    once?: boolean;
}
declare function watchEffect(effect: WatchEffect, options?: WatchEffectOptions): WatchHandle;
declare function watchPostEffect(effect: WatchEffect, options?: DebuggerOptions): WatchHandle;
declare function watchSyncEffect(effect: WatchEffect, options?: DebuggerOptions): WatchHandle;
type MultiWatchSources = Array<WatchSource<unknown> | object>;
declare function watch<T, Immediate extends Readonly<boolean> = false>(source: WatchSource<T>, cb: WatchCallback<T, MaybeUndefined<T, Immediate>>, options?: WatchOptions<Immediate>): WatchHandle;
declare function watch<T extends Readonly<MultiWatchSources>, Immediate extends Readonly<boolean> = false>(sources: readonly [...T] | T, cb: [T] extends [ReactiveMarker] ? WatchCallback<T, MaybeUndefined<T, Immediate>> : WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>, options?: WatchOptions<Immediate>): WatchHandle;
declare function watch<T extends MultiWatchSources, Immediate extends Readonly<boolean> = false>(sources: [...T], cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>, options?: WatchOptions<Immediate>): WatchHandle;
declare function watch<T extends object, Immediate extends Readonly<boolean> = false>(source: T, cb: WatchCallback<T, MaybeUndefined<T, Immediate>>, options?: WatchOptions<Immediate>): WatchHandle;

declare function nextTick<R = void>(fn?: () => R): Promise<Awaited<R>>;

interface InjectionConstraint<T> {
}
type InjectionKey<T> = symbol & InjectionConstraint<T>;
declare function provide<T, K = InjectionKey<T> | string>(key: K, value: K extends InjectionKey<infer V> ? V : T): void;
declare function inject<T>(key: InjectionKey<T> | string): T | undefined;
declare function inject<T>(key: InjectionKey<T> | string, defaultValue: T, treatDefaultAsFactory?: false): T;
declare function inject<T>(key: InjectionKey<T> | string, defaultValue: T | (() => T), treatDefaultAsFactory: true): T;

type Bindings = Record<string, any> | void;

type AppSetup = (this: void, options: WechatMiniprogram.App.LaunchShowOption) => Bindings;
type AppOptions<T extends WechatMiniprogram.IAnyObject> = {
    setup?: AppSetup;
} & WechatMiniprogram.App.Options<T>;
declare function createApp(setup: AppSetup): void;
declare function createApp<T extends WechatMiniprogram.IAnyObject>(options: AppOptions<T>): void;

type Query = Record<string, string | undefined>;
type PageContext = WechatMiniprogram.Page.InstanceProperties & Omit<WechatMiniprogram.Page.InstanceMethods<Record<string, any>>, 'setData' | 'groupSetData' | 'hasBehavior' | 'triggerEvent' | 'selectOwnerComponent' | 'getRelationNodes'>;
type PageSetup = (this: void, query: Query, context: PageContext) => Bindings;
type PageOptions<Data extends WechatMiniprogram.Page.DataOption, Custom extends WechatMiniprogram.Page.CustomOption> = {
    setup?: PageSetup;
} & WechatMiniprogram.Page.Options<Data, Custom>;
interface Config {
    listenPageScroll?: boolean;
    canShareToOthers?: boolean;
    canShareToTimeline?: boolean;
}
declare function definePage(setup: PageSetup, config?: Config): void;
declare function definePage<Data extends WechatMiniprogram.Page.DataOption, Custom extends WechatMiniprogram.Page.CustomOption>(options: PageOptions<Data, Custom>, config?: Config): void;

type ComponentContext = WechatMiniprogram.Component.InstanceProperties & Omit<WechatMiniprogram.Component.InstanceMethods<Record<string, any>>, 'setData' | 'groupSetData' | 'hasBehavior'>;
type ComponentSetup<Props extends Record<string, any>> = (this: void, props: Readonly<Props>, context: ComponentContext) => Bindings;
type ComponentOptions<Props extends WechatMiniprogram.Component.PropertyOption, Data extends WechatMiniprogram.Component.DataOption, Methods extends WechatMiniprogram.Component.MethodOption, Behavior extends WechatMiniprogram.Component.BehaviorOption> = WechatMiniprogram.Component.Options<Data, Props, Methods, Behavior> & {
    setup?: ComponentSetup<PropertyOptionToData<WechatMiniprogram.Component.FilterUnknownType<Props>>>;
};
/** * Temporary patch for https://github.com/wechat-miniprogram/api-typings/issues/97 ***/
type PropertyOptionToData<T extends WechatMiniprogram.Component.PropertyOption> = {
    [Name in keyof T]: PropertyToData<T[Name]>;
};
type PropertyToData<T extends WechatMiniprogram.Component.AllProperty> = T extends WechatMiniprogram.Component.PropertyType ? WechatMiniprogram.Component.ValueType<T> : T extends WechatMiniprogram.Component.AllFullProperty ? T['optionalTypes'] extends OptionalTypes<infer Option> ? WechatMiniprogram.Component.FullPropertyToData<T> | WechatMiniprogram.Component.ValueType<Option> : WechatMiniprogram.Component.FullPropertyToData<T> : never;
type OptionalTypes<T extends WechatMiniprogram.Component.PropertyType> = T[];
declare function defineComponent(setup: ComponentSetup<{}>, config?: Config): string;
declare function defineComponent<Props extends WechatMiniprogram.Component.PropertyOption, Data extends WechatMiniprogram.Component.DataOption, Methods extends WechatMiniprogram.Component.MethodOption, Behavior extends WechatMiniprogram.Component.BehaviorOption>(options: ComponentOptions<Props, Data, Methods, Behavior>, config?: Config): string;

declare const onAppShow: (hook: (options: WechatMiniprogram.App.LaunchShowOption) => unknown) => void;
declare const onAppHide: (hook: () => unknown) => void;
declare const onAppError: (hook: (error: string) => unknown) => void;
declare const onPageNotFound: (hook: (options: WechatMiniprogram.App.PageNotFoundOption) => unknown) => void;
declare const onUnhandledRejection: (hook: (options: WechatMiniprogram.OnUnhandledRejectionListenerResult) => unknown) => void;
declare const onThemeChange: (hook: (options: WechatMiniprogram.OnThemeChangeListenerResult) => unknown) => void;
declare const onShow: (hook: () => unknown) => void;
declare const onHide: (hook: () => unknown) => void;
declare const onUnload: (hook: () => unknown) => void;
declare const onRouteDone: (hook: () => unknown) => void;
declare const onPullDownRefresh: (hook: () => unknown) => void;
declare const onReachBottom: (hook: () => unknown) => void;
declare const onResize: (hook: (resize: WechatMiniprogram.Page.IResizeOption) => unknown) => void;
declare const onTabItemTap: (hook: (tap: WechatMiniprogram.Page.ITabItemTapOption) => unknown) => void;
declare const onPageScroll: (hook: (scroll: WechatMiniprogram.Page.IPageScrollOption) => unknown) => void;
declare const onShareAppMessage: (hook: (share: WechatMiniprogram.Page.IShareAppMessageOption) => WechatMiniprogram.Page.ICustomShareContent | WechatMiniprogram.Page.IAsyncCustomShareContent | Promise<WechatMiniprogram.Page.ICustomShareContent> | void | Promise<void>) => void;
declare const onShareTimeline: (hook: () => WechatMiniprogram.Page.ICustomTimelineContent | void) => void;
declare const onAddToFavorites: (hook: (share: WechatMiniprogram.Page.IAddToFavoritesOption) => WechatMiniprogram.Page.IAddToFavoritesContent) => void;
declare const onSaveExitState: (hook: () => WechatMiniprogram.Page.ISaveExitState) => void;
declare const onReady: (hook: () => unknown) => void;
declare const onLoad: (hook: (query: Query) => unknown) => void;
declare const onMove: (hook: () => unknown) => void;
declare const onDetach: (hook: () => unknown) => void;
declare const onError: (hook: (error: WechatMiniprogram.Error) => unknown) => void;

export { type AppOptions, type AppSetup, type Bindings, type ComponentContext, type ComponentOptions, type ComponentSetup, type Config, type InjectionKey, type MultiWatchSources, type PageContext, type PageOptions, type PageSetup, type Query, type WatchOptions, type WatchEffectOptions as WatchOptionsBase, createApp, defineComponent, definePage, inject, nextTick, onAddToFavorites, onAppError, onAppHide, onAppShow, onDetach, onError, onHide, onLoad, onMove, onPageNotFound, onPageScroll, onPullDownRefresh, onReachBottom, onReady, onResize, onRouteDone, onSaveExitState, onShareAppMessage, onShareTimeline, onShow, onTabItemTap, onThemeChange, onUnhandledRejection, onUnload, provide, watch, watchEffect, watchPostEffect, watchSyncEffect };
